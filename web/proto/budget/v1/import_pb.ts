// @generated by protoc-gen-es v1.10.1 with parameter "target=ts,import_extension=none"
// @generated from file budget/v1/import.proto (package budget.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from message budget.v1.StartCsvImportRequest
 */
export class StartCsvImportRequest extends Message<StartCsvImportRequest> {
  /**
   * @generated from field: string filename = 1;
   */
  filename = "";

  /**
   * default ","
   *
   * @generated from field: string delimiter = 2;
   */
  delimiter = "";

  /**
   * default '"'
   *
   * @generated from field: string quote = 3;
   */
  quote = "";

  /**
   * default "utf-8"
   *
   * @generated from field: string encoding = 4;
   */
  encoding = "";

  constructor(data?: PartialMessage<StartCsvImportRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "budget.v1.StartCsvImportRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filename", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "delimiter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "quote", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "encoding", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartCsvImportRequest {
    return new StartCsvImportRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartCsvImportRequest {
    return new StartCsvImportRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartCsvImportRequest {
    return new StartCsvImportRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartCsvImportRequest | PlainMessage<StartCsvImportRequest> | undefined, b: StartCsvImportRequest | PlainMessage<StartCsvImportRequest> | undefined): boolean {
    return proto3.util.equals(StartCsvImportRequest, a, b);
  }
}

/**
 * @generated from message budget.v1.StartCsvImportResponse
 */
export class StartCsvImportResponse extends Message<StartCsvImportResponse> {
  /**
   * @generated from field: string import_id = 1;
   */
  importId = "";

  constructor(data?: PartialMessage<StartCsvImportResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "budget.v1.StartCsvImportResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "import_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartCsvImportResponse {
    return new StartCsvImportResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartCsvImportResponse {
    return new StartCsvImportResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartCsvImportResponse {
    return new StartCsvImportResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StartCsvImportResponse | PlainMessage<StartCsvImportResponse> | undefined, b: StartCsvImportResponse | PlainMessage<StartCsvImportResponse> | undefined): boolean {
    return proto3.util.equals(StartCsvImportResponse, a, b);
  }
}

/**
 * @generated from message budget.v1.UploadCsvChunkRequest
 */
export class UploadCsvChunkRequest extends Message<UploadCsvChunkRequest> {
  /**
   * @generated from field: string import_id = 1;
   */
  importId = "";

  /**
   * @generated from field: bytes chunk = 2;
   */
  chunk = new Uint8Array(0);

  /**
   * @generated from field: bool last = 3;
   */
  last = false;

  constructor(data?: PartialMessage<UploadCsvChunkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "budget.v1.UploadCsvChunkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "import_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "last", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UploadCsvChunkRequest {
    return new UploadCsvChunkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UploadCsvChunkRequest {
    return new UploadCsvChunkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UploadCsvChunkRequest {
    return new UploadCsvChunkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UploadCsvChunkRequest | PlainMessage<UploadCsvChunkRequest> | undefined, b: UploadCsvChunkRequest | PlainMessage<UploadCsvChunkRequest> | undefined): boolean {
    return proto3.util.equals(UploadCsvChunkRequest, a, b);
  }
}

/**
 * @generated from message budget.v1.UploadCsvChunkResponse
 */
export class UploadCsvChunkResponse extends Message<UploadCsvChunkResponse> {
  /**
   * @generated from field: int64 received_bytes = 1;
   */
  receivedBytes = protoInt64.zero;

  constructor(data?: PartialMessage<UploadCsvChunkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "budget.v1.UploadCsvChunkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "received_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UploadCsvChunkResponse {
    return new UploadCsvChunkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UploadCsvChunkResponse {
    return new UploadCsvChunkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UploadCsvChunkResponse {
    return new UploadCsvChunkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UploadCsvChunkResponse | PlainMessage<UploadCsvChunkResponse> | undefined, b: UploadCsvChunkResponse | PlainMessage<UploadCsvChunkResponse> | undefined): boolean {
    return proto3.util.equals(UploadCsvChunkResponse, a, b);
  }
}

/**
 * @generated from message budget.v1.CsvColumnMapping
 */
export class CsvColumnMapping extends Message<CsvColumnMapping> {
  /**
   * @generated from field: string date_column = 1;
   */
  dateColumn = "";

  /**
   * @generated from field: string amount_column = 2;
   */
  amountColumn = "";

  /**
   * optional
   *
   * @generated from field: string currency_code_column = 3;
   */
  currencyCodeColumn = "";

  /**
   * income/expense or signed amounts
   *
   * @generated from field: string type_column = 4;
   */
  typeColumn = "";

  /**
   * to map names â†’ category_ids
   *
   * @generated from field: string category_column = 5;
   */
  categoryColumn = "";

  /**
   * @generated from field: string comment_column = 6;
   */
  commentColumn = "";

  constructor(data?: PartialMessage<CsvColumnMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "budget.v1.CsvColumnMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "date_column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount_column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "currency_code_column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "type_column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "category_column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "comment_column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CsvColumnMapping {
    return new CsvColumnMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CsvColumnMapping {
    return new CsvColumnMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CsvColumnMapping {
    return new CsvColumnMapping().fromJsonString(jsonString, options);
  }

  static equals(a: CsvColumnMapping | PlainMessage<CsvColumnMapping> | undefined, b: CsvColumnMapping | PlainMessage<CsvColumnMapping> | undefined): boolean {
    return proto3.util.equals(CsvColumnMapping, a, b);
  }
}

/**
 * @generated from message budget.v1.ConfigureCsvMappingRequest
 */
export class ConfigureCsvMappingRequest extends Message<ConfigureCsvMappingRequest> {
  /**
   * @generated from field: string import_id = 1;
   */
  importId = "";

  /**
   * @generated from field: budget.v1.CsvColumnMapping mapping = 2;
   */
  mapping?: CsvColumnMapping;

  constructor(data?: PartialMessage<ConfigureCsvMappingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "budget.v1.ConfigureCsvMappingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "import_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mapping", kind: "message", T: CsvColumnMapping },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigureCsvMappingRequest {
    return new ConfigureCsvMappingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigureCsvMappingRequest {
    return new ConfigureCsvMappingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigureCsvMappingRequest {
    return new ConfigureCsvMappingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigureCsvMappingRequest | PlainMessage<ConfigureCsvMappingRequest> | undefined, b: ConfigureCsvMappingRequest | PlainMessage<ConfigureCsvMappingRequest> | undefined): boolean {
    return proto3.util.equals(ConfigureCsvMappingRequest, a, b);
  }
}

/**
 * @generated from message budget.v1.ConfigureCsvMappingResponse
 */
export class ConfigureCsvMappingResponse extends Message<ConfigureCsvMappingResponse> {
  constructor(data?: PartialMessage<ConfigureCsvMappingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "budget.v1.ConfigureCsvMappingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigureCsvMappingResponse {
    return new ConfigureCsvMappingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigureCsvMappingResponse {
    return new ConfigureCsvMappingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigureCsvMappingResponse {
    return new ConfigureCsvMappingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigureCsvMappingResponse | PlainMessage<ConfigureCsvMappingResponse> | undefined, b: ConfigureCsvMappingResponse | PlainMessage<ConfigureCsvMappingResponse> | undefined): boolean {
    return proto3.util.equals(ConfigureCsvMappingResponse, a, b);
  }
}

/**
 * @generated from message budget.v1.PreviewCsvImportRequest
 */
export class PreviewCsvImportRequest extends Message<PreviewCsvImportRequest> {
  /**
   * @generated from field: string import_id = 1;
   */
  importId = "";

  /**
   * @generated from field: int32 limit = 2;
   */
  limit = 0;

  constructor(data?: PartialMessage<PreviewCsvImportRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "budget.v1.PreviewCsvImportRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "import_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PreviewCsvImportRequest {
    return new PreviewCsvImportRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PreviewCsvImportRequest {
    return new PreviewCsvImportRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PreviewCsvImportRequest {
    return new PreviewCsvImportRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PreviewCsvImportRequest | PlainMessage<PreviewCsvImportRequest> | undefined, b: PreviewCsvImportRequest | PlainMessage<PreviewCsvImportRequest> | undefined): boolean {
    return proto3.util.equals(PreviewCsvImportRequest, a, b);
  }
}

/**
 * @generated from message budget.v1.PreviewCsvImportResponse
 */
export class PreviewCsvImportResponse extends Message<PreviewCsvImportResponse> {
  /**
   * @generated from field: int32 total_rows = 1;
   */
  totalRows = 0;

  /**
   * @generated from field: int32 valid_rows = 2;
   */
  validRows = 0;

  /**
   * @generated from field: int32 invalid_rows = 3;
   */
  invalidRows = 0;

  constructor(data?: PartialMessage<PreviewCsvImportResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "budget.v1.PreviewCsvImportResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "total_rows", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "valid_rows", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "invalid_rows", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PreviewCsvImportResponse {
    return new PreviewCsvImportResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PreviewCsvImportResponse {
    return new PreviewCsvImportResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PreviewCsvImportResponse {
    return new PreviewCsvImportResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PreviewCsvImportResponse | PlainMessage<PreviewCsvImportResponse> | undefined, b: PreviewCsvImportResponse | PlainMessage<PreviewCsvImportResponse> | undefined): boolean {
    return proto3.util.equals(PreviewCsvImportResponse, a, b);
  }
}

/**
 * @generated from message budget.v1.CommitCsvImportRequest
 */
export class CommitCsvImportRequest extends Message<CommitCsvImportRequest> {
  /**
   * @generated from field: string import_id = 1;
   */
  importId = "";

  /**
   * @generated from field: bool dry_run = 2;
   */
  dryRun = false;

  constructor(data?: PartialMessage<CommitCsvImportRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "budget.v1.CommitCsvImportRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "import_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dry_run", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommitCsvImportRequest {
    return new CommitCsvImportRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommitCsvImportRequest {
    return new CommitCsvImportRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommitCsvImportRequest {
    return new CommitCsvImportRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CommitCsvImportRequest | PlainMessage<CommitCsvImportRequest> | undefined, b: CommitCsvImportRequest | PlainMessage<CommitCsvImportRequest> | undefined): boolean {
    return proto3.util.equals(CommitCsvImportRequest, a, b);
  }
}

/**
 * @generated from message budget.v1.CommitCsvImportResponse
 */
export class CommitCsvImportResponse extends Message<CommitCsvImportResponse> {
  /**
   * @generated from field: int32 inserted = 1;
   */
  inserted = 0;

  /**
   * @generated from field: int32 failed = 2;
   */
  failed = 0;

  constructor(data?: PartialMessage<CommitCsvImportResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "budget.v1.CommitCsvImportResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inserted", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "failed", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommitCsvImportResponse {
    return new CommitCsvImportResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommitCsvImportResponse {
    return new CommitCsvImportResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommitCsvImportResponse {
    return new CommitCsvImportResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CommitCsvImportResponse | PlainMessage<CommitCsvImportResponse> | undefined, b: CommitCsvImportResponse | PlainMessage<CommitCsvImportResponse> | undefined): boolean {
    return proto3.util.equals(CommitCsvImportResponse, a, b);
  }
}

